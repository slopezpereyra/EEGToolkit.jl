<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · EEGToolkit.jl</title><meta name="title" content="Home · EEGToolkit.jl"/><meta property="og:title" content="Home · EEGToolkit.jl"/><meta property="twitter:title" content="Home · EEGToolkit.jl"/><meta name="description" content="Documentation for EEGToolkit.jl."/><meta property="og:description" content="Documentation for EEGToolkit.jl."/><meta property="twitter:description" content="Documentation for EEGToolkit.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="EEGToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>EEGToolkit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Package-Features"><span>Package Features</span></a></li><li><a class="tocitem" href="#Time-series"><span>Time series</span></a></li><li><a class="tocitem" href="#EEG"><span>EEG</span></a></li><li><a class="tocitem" href="#NREM-Period-detection"><span>NREM Period detection</span></a></li><li><a class="tocitem" href="#Spindle-detection"><span>Spindle detection</span></a></li><li><a class="tocitem" href="#Power-spectral-analysis"><span>Power spectral analysis</span></a></li><li><a class="tocitem" href="#Helpers"><span>Helpers</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/slopezpereyra/EEGToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="EEGToolkit.jl"><a class="docs-heading-anchor" href="#EEGToolkit.jl">EEGToolkit.jl</a><a id="EEGToolkit.jl-1"></a><a class="docs-heading-anchor-permalink" href="#EEGToolkit.jl" title="Permalink"></a></h1><p><em>Computational EEG analysis with emphasis in sleep neuroscience.</em></p><hr/><blockquote><p>Developed at the <a href="https://www.med.upenn.edu/slowwavelab/">Laboratory for the Study of Sleep Slow-wave activity</a></p></blockquote><hr/><blockquote><p>The Gods of the earth and sea<br/>Sought thro&#39; Nature to find this Tree,<br/>But their search was all in vain:<br/>There grows one in the Human Brain.</p><p>— William Blake</p></blockquote><hr/><p>This package has three aims: </p><ul><li>Simplicity</li><li>Transparency</li><li>Efficiency</li></ul><p><em>Simplicity</em> means that a person with only basic programming skills should be able to use it. <em>Transparency</em> means that any methodology implemented by the package should be accessible enough so as to be reported in a scientific paper. <em>Efficiency</em> means that large EEGs (e.g. sleep EEGs) should be processed and analyzed in seconds.</p><hr/><blockquote><p>This package is free software—free as in freedom. You are free to use the code as you wish and for any purpose. You are free to study the code and change it to make it do what you wish. You are free to redistribute copies of this package to help others. You are free to distribute copies of any modified version of this package. </p><p>Proprietary software hinders the liberty of its users. In science, it obscures the scientific process, difficulting replication and collaboration. If you are a scientist, use free software whenever possible.</p></blockquote><hr/><h2 id="Package-Features"><a class="docs-heading-anchor" href="#Package-Features">Package Features</a><a id="Package-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Package-Features" title="Permalink"></a></h2><ul><li>Loading and processing EEG data</li><li>EEG visualization</li><li>Sleep stage handling </li><li>NREM Period detection</li><li>Power spectral analysis</li><li>Spindle detection algorithms</li></ul><h2 id="Time-series"><a class="docs-heading-anchor" href="#Time-series">Time series</a><a id="Time-series-1"></a><a class="docs-heading-anchor-permalink" href="#Time-series" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.TimeSeries" href="#EEGToolkit.TimeSeries"><code>EEGToolkit.TimeSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A struct representing time series data.</p><p><strong>Fields</strong></p><ul><li><code>x::Vector{&lt;:AbstractFloat}</code>: Time series data.</li><li><code>fs::Integer</code>: Sampling rate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/ts.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.segment" href="#EEGToolkit.segment"><code>EEGToolkit.segment</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>segment(v::Vector{T}, L::Int; overlap::Union{&lt;:AbstractFloat,Integer}=0, symmetric=false) where {T}</code></p><p>Splits a vector <code>v</code> into segments of length <code>L</code> with an overlap <code>overlap</code> expressed as a fraction of L. The <code>overlap</code> defaults to <code>0</code> (no overlap). Returns a vector <span>$v$</span> of vectors - i.e. <code>Vector{Vector{T}}</code> - with <span>$\vec{v_i}$</span> the <span>$i$</span>th segment in the split.</p><p>The function always attempts to capture the whole vector, even if the final split is not of length L. For example, </p><pre><code class="language-julia hljs">&gt; x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
&gt; segment(x, 5)
2-element Vector{Vector{Int64}}:
[1, 2, 3, 4, 5]
[6, 7, 8, 9, 0]

&gt; segment(x, 7)
2-element Vector{Vector{Int64}}:
[1, 2, 3, 4, 5, 6, 7]
[8, 9, 0]</code></pre><p>Set <code>symmetric=true</code> to ensure that, if this occurs, the last split is dropped.</p><pre><code class="language-julia hljs">&gt; segment(x, 3; symmetric=true)
3-element Vector{Vector{Int64}}:
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]</code></pre><p>If <code>L</code> is equal to the segment length, <code>segment</code> raises a warning and returns a vector with only the original vector: <code>[v]</code>.  The return value ensures type-safety but the warning is raised because  splitting a vector over its length is potentially  a programming mistake.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/ts.jl#L47-L83">source</a></section><section><div><p><code>segment(ts::TimeSeries, L::Int; kargs...)</code></p><p>Wrapper to segment the vector <code>ts.x</code> in the time  series <code>ts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/ts.jl#L129-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.epoch" href="#EEGToolkit.epoch"><code>EEGToolkit.epoch</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>epoch(signal::TimeSeries, n::Integer; epoch_length::Integer=30)</code></p><p>Returns a vector <code>[x₁, …, xₖ]</code> with all values <code>xᵢ</code> corresponding to the <code>n</code>th epoch in the signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/ts.jl#L215-L219">source</a></section><section><div><p><code>epoch(signal::TimeSeries, n::Integer, m::Integer)</code></p><p>Returns a vector <code>[x₁, …, xₖ]</code> with all indexes corresponding to epochs <code>n, n+1, …, m</code> of the EEG. The default sampling rate is used to compute the indexes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/ts.jl#L231-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.plot_ts" href="#EEGToolkit.plot_ts"><code>EEGToolkit.plot_ts</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>plot_ts(ts::TimeSeries, s::Integer, e::Integer; norm=false, ylab=&quot;Amplitude (uV)&quot;)</code></p><p>Plots <code>TimeSeries</code> from epoch <code>s</code> to epoch <code>e</code>. The series many be normalized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/ts.jl#L255-L259">source</a></section><section><div><p><code>plot_ts(ts::TimeSeries, s::Integer; kargs...)</code></p><p>Plots <code>TimeSeries</code> at epoch <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/ts.jl#L268-L272">source</a></section><section><div><p><code>plot_ts(ts::TimeSeries; norm=false, ylab=&quot;Amplitude (uV)&quot;)</code></p><p>Plots <code>TimeSeries</code>. The series may be normalized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/ts.jl#L277-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.seconds_to_time" href="#EEGToolkit.seconds_to_time"><code>EEGToolkit.seconds_to_time</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>seconds_to_time(seconds::Union{AbstractFloat, Integer})</code></p><p>Helper function: maps a time in seconds to a Time object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/ts.jl#L139-L143">source</a></section></article><h2 id="EEG"><a class="docs-heading-anchor" href="#EEG">EEG</a><a id="EEG-1"></a><a class="docs-heading-anchor-permalink" href="#EEG" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.EEG" href="#EEGToolkit.EEG"><code>EEGToolkit.EEG</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A struct for the EEG data type. An EEG is simply conceived as a collection of labeled time series.</p><p><strong>Fields</strong></p><ul><li><code>signals::Dict{String, TimeSeries}</code>: A dictionary mapping signal labels (strings) to arrays of floating-point values.</li></ul><p><strong>Constructors</strong></p><p><code>EEG(file::String; id::String=&quot;&quot;)</code>: Instantiates an <code>EEG</code> from an EDF file (<code>file</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">eeg_data = EEG(&quot;path/to/edf_data/data.edf&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/eeg.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.remove_channel!" href="#EEGToolkit.remove_channel!"><code>EEGToolkit.remove_channel!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>remove_channel!(eeg::EEG, channel::String)</code></p><p>Removes a channel from the EEG.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/eeg.jl#L85-L89">source</a></section><section><div><p><code>remove_channel!(eeg::EEG, channels::Vector{String})</code></p><p>Removes a list of channels from the EEG.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/eeg.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.plot_eeg" href="#EEGToolkit.plot_eeg"><code>EEGToolkit.plot_eeg</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>plot_eeg(eeg::EEG, s::Integer, e::Integer; channels::Vector{String}=[&quot;&quot;], spacing::AbstractFloat=1.5)</code></p><p>Plots EEG channels from epoch <code>s</code> to epoch <code>e</code>. Specific channels may be selected with the <code>channels</code> karg. The <code>spacing</code> argument is an added factor in the normalization of the EEG signals - the vertical distance between each signal in the plot grows proportionally to <code>spacing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/eeg.jl#L104-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.artifact_reject" href="#EEGToolkit.artifact_reject"><code>EEGToolkit.artifact_reject</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>artifact_reject(signal::TimeSeries, anom_matrix::Matrix; epoch_length::Integer=30, subepoch_length::Integer=5)</code></p><p>This  function  requires  <code>TimeSeries</code>   and  an  anomaly  matrix  <span>$A$</span>,  and has epoch and subepoch lengths (in seconds) as optional parameters. An anomaly matrix <span>$A  \in  \mathbb{N}^{n  \times  2}$</span>  is  a  matrix which holds epoch-subepoch   pairs   that   contain    artifacts    in    a    <code>TimeSeries</code>. Each row <span>$(n, m)$</span> of <span>$A$</span> denotes that the <span>$n$</span>th epoch contained  an artifact within sub-epoch <span>$m$</span>. </p><p>The function   removes   from   the   signal   the   epoch-subepoch    pairs    containing artifacts. In particular, this function returns a  <code>Vector{Vector{T}}</code> with <code>T&lt;:AbstractFloat</code>. Thus, if  <code>result</code>   holds   the   return   value   of    this    function,    <code>result[i]</code> contains   what   is   left   from    the    <code>i</code>th    epoch    after    removing its   contaminated   sub-epochs.   It   is   possible   that   <code>result[i]</code>    is empty, if all sub-epochs of epoch <code>i</code> contained artifacts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/ts.jl#L289-L307">source</a></section><section><div><p><code>artifact_reject(signal::TimeSeries, anoms::Vector{Integer}; epoch_length::Integer=30)</code></p><p>An anomaly vector <span>$\vec{x} \in \mathbb{N}^{n}$</span> is a sorted vector whose values are those epochs in an <code>TimeSeries</code> that contain  anomalies or artifacts. This function segments the TimeSeries and filters out all  epochs containing artifacts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/ts.jl#L329-L336">source</a></section></article><h2 id="NREM-Period-detection"><a class="docs-heading-anchor" href="#NREM-Period-detection">NREM Period detection</a><a id="NREM-Period-detection-1"></a><a class="docs-heading-anchor-permalink" href="#NREM-Period-detection" title="Permalink"></a></h2><h4 id="NREM-period-definition"><a class="docs-heading-anchor" href="#NREM-period-definition">NREM period definition</a><a id="NREM-period-definition-1"></a><a class="docs-heading-anchor-permalink" href="#NREM-period-definition" title="Permalink"></a></h4><p>Following <a href="https://pubmed.ncbi.nlm.nih.gov/220659/">Feinberg &amp; Floyed</a> and Dijk, a NREM period is a sequence of epochs satisfying the following conditions:</p><ul><li>It starts with stages 2, 3 or 4. </li><li>It contains at least 15 minutes of stages 2, 3 or 4 in total.</li><li>It ends with 5 or more minutes of REM, or with 5 or more minutes of wakefulness. </li></ul><p>Epochs in the sequence are allowed to contain occurrences of REM sleep or wakefulness  in between, as long as the duration of this occurrences is less than 5 minutes. But the epochs corresponding to these occurrences will not be part of the NREM period. For example, in a stage sequence of the form</p><p>... - 10m of stage two - 1m of REM - 5m of stage three - 5m of REM - ...</p><p>the NREM period consists of the first 10 minutes of stage 2 and the 5 minutes of stage 3, ignoring the 1 minute of REM in-between them.</p><p>Importantly, the restriction that ending REM periods must last at least 5 minutes is not imposed when detecting the first and the last NREM period in a night of sleep.</p><h4 id="NREM-detection-algorithm"><a class="docs-heading-anchor" href="#NREM-detection-algorithm">NREM detection algorithm</a><a id="NREM-detection-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#NREM-detection-algorithm" title="Permalink"></a></h4><p>Let <span>$n$</span> be the number of epochs corresponding to <span>$15$</span> minutes and <span>$m$</span> the number of epochs corresponding to <span>$5$</span> minutes. (In 30 second epochs, <span>$n = 30, m = 10$</span>). </p><p>The algorithm assumes that the  <code>staging</code> field of an <code>EEG</code> has been set to a vector <span>$\vec{s}$</span> that contains only the strings <span>$1, \ldots, 6, ?$</span> (with <span>$5$</span> marking REM, <span>$6$</span> wakefulness, <span>$?$</span> unknown/unstaged).</p><p>The algorithm works by mapping <span>$\vec{s}$</span> to <span>$\alpha = s_1 \ldots s_q$</span> a word over the language generated by <span>$\Sigma = \{1, \ldots, 6, ?\}$</span>.</p><p>Observe that the language <span>$[(5+6)^*(2+3+4)^*]^*$</span> is partitioned into <span>$U$</span> and <span>$U’$</span>, where <span>$U$</span> is the set of words containing at least <span>$n$</span> symbols <span>$2, 3, 4$</span> where neither <span>$5$</span> nor <span>$6$</span> occur consecutively <span>$m$</span> times. Then <span>$\alpha$</span> can be decomposed into </p><p class="math-container">\[\alpha = \psi_1 \phi_1 \psi_2 \phi_2 \ldots \psi_k \phi_k \psi_{k+1}\]</p><p>where <span>$\phi_i = \varphi_i (5^m5^* + 6^m6^*)$</span> and <span>$\varphi_i \in U$</span>. Such a decomposition readily provides the number of NREM periods in the EEG (i.e. <span>$k$</span>). Furthermore, the epochs which comprise these periods are easily inferable from the decomposition.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.nrem" href="#EEGToolkit.nrem"><code>EEGToolkit.nrem</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>nrem(staging::Vector, n::Integer=30, m::Integer=10)</code></p><p>Finds the <code>k</code> underlying NREM periods in a staging vector. Returns a vector of vectors <code>V</code> s.t. the <code>i</code>th vector in <code>V</code>  contains the epochs which comprise the <code>i</code>th NREM period. Thus, the length of <code>V</code> is <code>k</code> the number of NREM periods.</p><p>The <code>n</code> parameter is the number of (not necessarily consecutive)  epochs which comprise a NREM period. The <code>m</code> parameter is the  number of REM or wakefulness epochs required to mark the end  of a NREM period (if <code>n</code> NREM epochs were parsed before) or to  disregard the current sequence and begin parsing from the next  NREM epoch.</p><p>The <code>staging</code> parameter is a vector containing only the  symbols <code>1, …, 6, ?</code> where <code>5</code> denotes REM, <code>6</code> denotes  wakefulness, and <code>?</code> denotes unscored/unstaged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/nrem.jl#L48-L66">source</a></section></article><h2 id="Spindle-detection"><a class="docs-heading-anchor" href="#Spindle-detection">Spindle detection</a><a id="Spindle-detection-1"></a><a class="docs-heading-anchor-permalink" href="#Spindle-detection" title="Permalink"></a></h2><p>This package implements two spindle detection algorithms discussed in <a href="https://doi.org/10.3389/fnhum.2015.00353">O&#39;Reilly and Nielsen (2015)</a>. We give a brief overview of them here but refer to their original publications for further detail.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.sigma_index" href="#EEGToolkit.sigma_index"><code>EEGToolkit.sigma_index</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>sigma_index(x::Vector{&lt;:AbstractFloat}, fs::Integer)</code></p><p>The <span>$\sigma$</span>-index algorithm <a href="https://pubmed.ncbi.nlm.nih.gov/17555950/">(Huupponen et al., 2007)</a> find abnormally high amplitude values in the spindle frequency band. Per each 1 second window of the EEG, it computes</p><ul><li>the maximum amplitude in the spindle frequency band, which we call <span>$S_{max}$</span></li><li>the average amplitude in the low alpha and theta frequencies, which we call</li></ul><p><span>$\alpha_{mean}, \theta_{mean}$</span></p><ul><li>the maximum alpha amplitude <span>$\alpha_{max}$</span></li></ul><p>The <span>$\sigma$</span>-index of each window is defined to be zero if <span>$\alpha_max &gt; S_{max}$</span>, and otherwise</p><p class="math-container">\[f(S_{max}, \alpha_{mean}, \phi_{mean}) = \frac{2S_{max}}{ \alpha_{mean} + \theta_{mean} } \]</p><p>Higher values are indicative of a higher spindle probability. The rejection threshold recommended in the original paper is <span>$\lambda = 4.5$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/spindles.jl#L2-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.relative_spindle_power" href="#EEGToolkit.relative_spindle_power"><code>EEGToolkit.relative_spindle_power</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>relative_spindle_power(x::Vector{&lt;:AbstractFloat}, fs::Integer)</code></p><p>The Relative Spindle Power (RSP) algorithm <a href="https://pubmed.ncbi.nlm.nih.gov/22254656/">(Devuyst et al., 2011)</a>  also detects abnormal values along the spindle frequency band.  For every 1 second window, the amplitude spectrum <span>$S(t)$</span> is computed,  and the RSP is defined as</p><p class="math-container">\[RSP(t) = \frac{\int_{11}^{16} S(t, f) df}{\int_{0.5}^{40} S(t, f) df}\]</p><p>This definition is more intelligible than the that of the <span>$\sigma$</span>-index, insofar as it represents the ratio of the total power in the spindle band with respect to the total power in the <span>$[0.5, 40]$</span> frequency range. It is evident by definition that <span>$0 \leq RSP \leq 1$</span>. Higher values are indicative of a higher spindle probability (it should be clear that <span>$RSP$</span> is not a probability itself). The rejection threshold recommended in the original paper is <span>$\lambda = 0.22$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/spindles.jl#L52-L70">source</a></section></article><h2 id="Power-spectral-analysis"><a class="docs-heading-anchor" href="#Power-spectral-analysis">Power spectral analysis</a><a id="Power-spectral-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Power-spectral-analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.AmplitudeSpectrum" href="#EEGToolkit.AmplitudeSpectrum"><code>EEGToolkit.AmplitudeSpectrum</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure for amplitude spectrum estimations. Estimations are by default  one sided, with frequencies ranging from [0, fₛ/2]. The formula used is </p><p class="math-container">\[\frac{2|H(f)|}{\sum_i w_i}\]</p><p>with <span>$w_i$</span> a Hanning window.</p><p><strong>Fields</strong></p><ul><li><code>freq::Vector{&lt;:AbstractFloat}</code>: Frequency range of the spectrum</li><li><code>spectrum::Vector{&lt;:AbstractFloat}</code>: Estimated spectral amplitude</li></ul><p><strong>Constructors</strong></p><p><code>AmplitudeSpectrum(x::Vector{&lt;:AbstractFloat}, sampling_rate::Integer, pad::Integer)</code> : Computes a direct PSD over a signal <code>x</code> with a given <code>sampling_rate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/psd.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.PSD" href="#EEGToolkit.PSD"><code>EEGToolkit.PSD</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure for PSD estimations. Estimations are by default  one sided, with frequencies ranging from [0, fₛ/2].</p><p>The default formula is </p><p class="math-container">\[\frac{2|H(f)|^2}{\zeta \sum_i w_i^2}\]</p><p>with <span>$w_1, \ldots, w_n$</span> a Hanning window and <span>$\zeta$</span> a normalization factor which defaults  to <span>$1$</span>.  </p><p>Barlett or Welch&#39;s mehtod can be used, where the formula  becomes </p><p class="math-container">\[\frac{1}{M K \varphi} \sum_i^M \left[ \frac{2|H_i(f)|^2}{ \sum_i w_i^2} \right]\]</p><p>where <span>$w_1, \ldots, w_n$</span> a Hanning window, <span>$M$</span> the number of segments, <span>$K$</span> the number of samples per segment, <span>$H_i(f)$</span> the FFT of the <span>$i$</span>th segment of the signal, and <span>$\varphi$</span> a normalization factor defaulting to <code>1</code>.</p><p><strong>Fields</strong></p><ul><li><code>freq::Vector{&lt;:AbstractFloat}</code>: Frequency range of the spectrum</li><li><code>spectrum::Vector{&lt;:AbstractFloat}</code> : Estimated spectral density in dB.</li></ul><p><strong>Constructors</strong></p><ul><li><code>PSD(x::Vector{&lt;:AbstractFloat}, fs::Integer; window_function::Function = hanning, pad::Integer=0, normalization::Real=1)</code>: Computes PSD estimation of a signal <code>x</code> with sampling rate <code>fs</code>. A <code>window_function</code> is applied to the signal, defaulting to a Hanning window. The signal may be padded to an optional length <code>pad</code> (defaults to zero, i.e. no padding). A <code>Real</code> <code>normalization</code> is added to the denominator, which defaults to <code>1</code>.</li><li><code>PSD(segs::Vector{Vector{T}}, fs::Integer; window_function=hanning, normalization::Real=1) where {T&lt;:AbstractFloat}</code>: Computes the average spectrum of the segment vectors <code>segs</code>. The estimation is normalized with a <code>normalization</code> that defaults to <span>$1$</span>. The <code>window_function</code> is applied to all segments prior to their PSD estimation.</li></ul><p><code>PSD(x::Vector{&lt;:AbstractFloat}, fs::Integer, seg_length::Integer; overlap::Union{&lt;:AbstractFloat,Integer} = 0.5, window_function::Function=hanning, normalization::Real=1)</code>: Segments the signal <code>x</code> into segments of length <code>seg_length</code>, with an overlap of <code>overlap</code> which defaults to 0.5 (half the segment length). After signal segmentation, the average spectrum of the resulting segments is returned. A <code>window_function</code> is applied to all segments prior to their PSD estimation, defaulting to a Hanning window. The final estimation is normalized with a <code>normalization</code> factor that defaults to <code>1</code>.</p><ul><li><code>PSD(ts::TimeSeries; kargs...)</code> : Wrapper to apply the first or second constructor to a TimeSeries signal.</li><li><code>PSD(ts::TimeSeries, seg_length::Integer; kargs...)</code>: Wrapper to apply the third constructor to a TimeSeries signal.</li><li><code>PSD(freq::Vector{&lt;:AbstractFloat},  spectrum::Vector{&lt;:AbstractFloat})</code>: Direct constructor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/psd.jl#L35-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.plot_psd" href="#EEGToolkit.plot_psd"><code>EEGToolkit.plot_psd</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>plot_psd(psd::PSD; freq_lim=30.0)</code></p><p>Plot a PSD with x-axis being frequency and y-axis being estimated power spectrum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/psd.jl#L266-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.Spectrogram" href="#EEGToolkit.Spectrogram"><code>EEGToolkit.Spectrogram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A spectrogram is a matrix <span>$S^{M \times F}$</span> where <span>$M$</span> is the number of windows in  the windowing of a signal and <span>$F$</span> is the length of the spectrum vector in any given window (i.e. the frequency resolution).  It is useful to observe spectral changes in time or to compute the  spectrum of time-regions of interest (e.g. only NREM periods in a sleep EEG).  The information available in direct PSD can be inferred from the spectrogram with ease.</p><p>For instance, let <span>$f_1, f_2, \ldots, f_k$</span> be a strictly increasing sequence of frequencies. Assume these frequencies correspond to the column indexes <span>$c_1, c_2, \ldots, c_k$</span> of <span>$S$</span>. Then the mean power in the frequency range  <span>$[f_1, f_k]$</span> is</p><p class="math-container">\[\frac{1}{M} \sum_{i=1}^{M}\left[\frac{1}{c_k - c_1}\sum_{j=c_1}^{c_k} S_{ij}\right] = \frac{1}{M\big(c_k - c_1\big)}\sum_{i=1}^{M}\sum_{j=c_1}^{c_k} S_{ij}\]</p><p>In this package, mean power in a frequency range is computed with the <code>mean_band_power</code> function.</p><p><strong>Fields</strong></p><ul><li><code>time::Vector</code> : Time domain </li><li><code>freq::Vector{&lt;:AbstractFloat}</code>: Frequency domain </li><li><code>spectrums::Matrix{&lt;:AbstractFloat}</code>: Power spectrum. Rows are time and columns are frequency; the value in <code>spectrums[row, freq]</code> is the power at time window <code>row</code> for frequency <code>freq</code>.</li><li><code>segment_length::Integer</code> : Length of each segment in time.</li><li><code>aggregated_spectra::Vector{&lt;:AbstractFloat}</code> : Spectral average (mean of rows)</li></ul><p><strong>Constructors</strong></p><ul><li><code>Spectrogram(segs::Vector{Vector{T}}, psd_function::Function; dB = false) where {T&lt;:AbstractFloat}</code>: Given a sequence of windows <span>$w_1, \ldots, w_k$</span> contained in the <code>segs</code> argument, computes the PSD within each window using a custom <code>psd_function</code>. </li><li><code>Spectrogram(signal::Vector{&lt;:AbstractFloat}, window_length::Integer, psd_function::Function; overlap::Union{AbstractFloat, Integer}=0, dB=false)</code>: Splits a signal into (potentially overlapping) segments of length <code>window_length</code> and computes the <code>Spectrogram</code> over this windowing using the first constructor. A custom <code>psd_function</code> is used within each window. Symmetry is enforced over the split signal, meaning that if the last segment is of length not equal to the rest, it is dropped. Thus, all windows are of equal length.</li><li><code>function Spectrogram(ts::TimeSeries, window_length::Integer, psd_function::Function; kargs...)</code>: Wrapper constructor for a <code>TimeSeries</code> object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/psd.jl#L174-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.plot_spectrogram" href="#EEGToolkit.plot_spectrogram"><code>EEGToolkit.plot_spectrogram</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>plot_spectrogram(spec::Spectrogram; freq_lim::AbstractFloat=30.0, type::Int=1, color=:nipy_spectral)</code></p><p>Plots a spectogram <code>spec</code> either in 2d (<code>type = 1</code>) or 3d (<code>type = 2</code>). An optional  frequency limit (<code>freq_lim</code>) may be set (defaults to 30Hz). The color palette  <code>color</code> may be set; defaults to <code>nipy_spectral</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/psd.jl#L246-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.freq_band" href="#EEGToolkit.freq_band"><code>EEGToolkit.freq_band</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>freq_band(spec::Union{PSD}, lower::AbstractFloat, upper::AbstractFloat)</code></p><p>Given a <code>PSD</code>, returns a <code>Vector{&lt;:AbstractFloat}</code> with the powers within the frequency band <code>[lower, upper]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/psd.jl#L308-L312">source</a></section><section><div><p><code>freq_band(spec::Spectrogram, lower::AbstractFloat, upper::AbstractFloat, window::Integer)</code></p><p>Given a <code>Spectrogram</code>, returns a <code>Vector{&lt;:AbstractFloat}</code> with the powers within a frequency band <code>[lower, upper]</code> of a specific window (row of the spectrogram).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/psd.jl#L319-L324">source</a></section><section><div><p><code>freq_band(spec::Spectrogram, lower::AbstractFloat, upper::AbstractFloat)</code></p><p>Given a <code>Spectrogram</code>, returns a <code>Matrix{&lt;:AbstractFloat}</code> with the powers within a frequency band [lower, upper] across all time windows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/psd.jl#L331-L336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.mean_band_power" href="#EEGToolkit.mean_band_power"><code>EEGToolkit.mean_band_power</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>mean_band_power(spec::Spectrogram, lower::AbstractFloat, upper::AbstractFloat)</code></p><p>Given a <code>Spectrogram</code>, returns the mean power in a given frequency band <code>[lower, upper]</code>. This function  effectively computes </p><p class="math-container">\[\frac{1}{M\big(c_k - c_1\big)}\sum_{i=1}^{M}\sum_{j=c_1}^{c_k} S_{ij}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/psd.jl#L343-L352">source</a></section><section><div><p><code>mean_band_power(spec::PSD, lower::AbstractFloat, upper::AbstractFloat)</code></p><p>Given a <code>PSD</code>, returns the mean power in a given frequency band <code>[lower, upper]</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/psd.jl#L362-L366">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.total_band_power" href="#EEGToolkit.total_band_power"><code>EEGToolkit.total_band_power</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>total_band_power(psd::PSD, lower::AbstractFloat, upper::AbstractFloat)</code></p><p>Given a PSD, computes the total power in the frequency band <code>[lower, upper]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/psd.jl#L372-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.analyze_eeg" href="#EEGToolkit.analyze_eeg"><code>EEGToolkit.analyze_eeg</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>analyze_eeg(signal::Vector{&lt;:AbstractFloat}, fs::Integer)::Spectrogram</code></p><p>Perform a standardized analysis of an EEG signal. This analysis procedure  succesfully replicated results from Washington State University in collaboration with the developer&#39;s laboratory at UPenn. </p><p>The standardized procedure is as follows: split the signal into 30-sec epochs, each of which is split into 5-sec sub-epochs. Each epoch&#39;s spectrum is the  aggregated spectra from its sub-epochs; the signal&#39;s spectrum is the aggregated  spectra from its epochs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/psd.jl#L124-L136">source</a></section><section><div><p><code>analyze_eeg(signal::Vector{&lt;:AbstractFloat}, fs::Integer, epoch_indexes::Vector{&lt;:Integer})::Spectrogram</code></p><p>Perform a standardized analysis of the specified epochs of an EEG signal.  This analysis procedure succesfully replicated results from Washington State  University in collaboration with the developer&#39;s laboratory at UPenn. </p><p>The standardized procedure is as follows: split the signal into 30-sec epochs, each of which is split into 5-sec sub-epochs. Each epoch&#39;s spectrum is the  aggregated spectra from its sub-epochs; the signal&#39;s spectrum is the aggregated  spectra from its epochs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/psd.jl#L148-L160">source</a></section></article><h2 id="Helpers"><a class="docs-heading-anchor" href="#Helpers">Helpers</a><a id="Helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Helpers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.next_power_of_two" href="#EEGToolkit.next_power_of_two"><code>EEGToolkit.next_power_of_two</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Given an integer <span>$n$</span>, finds the least <span>$m = 2^k$</span> s.t. <span>$m \geq n$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/psd.jl#L277-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EEGToolkit.zero_pad" href="#EEGToolkit.zero_pad"><code>EEGToolkit.zero_pad</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>zero_pad(v::Vector{T}, desired_length::Integer) where {T&lt;:AbstractFloat}</code></p><p>Zero-pads a numeric vector <code>v</code> to a <code>desired_length</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slopezpereyra/EEGToolkit.jl/blob/a18ec8ff4ff931766d07ec251e30b47c756c4f42/src/psd.jl#L288-L292">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h4 id="NREM-delta-power"><a class="docs-heading-anchor" href="#NREM-delta-power">NREM delta power</a><a id="NREM-delta-power-1"></a><a class="docs-heading-anchor-permalink" href="#NREM-delta-power" title="Permalink"></a></h4><p>This is an example script for computing the mean <span>$\delta$</span> (delta) power in each of the NREM periods of a sleep EEG. We will use the C3 channel.</p><pre><code class="language-julia hljs"># First, import the package
using EEGToolkit 

# Assuming we have the stage data in a .csv and we have some function 
# to read CSVs (e.g. from the CSV package)
staging_df = some_function_to_read_csv(&quot;my_staging_data.csv&quot;)

# Assuming the csv had a column named STAGES with the stage of each epoch.
staging = staging_df.STAGES

# We read an EEG that has channels C3-A2 and F3-A1. We assume the CSV had a 
# column called STAGES with the stages of each epoch.
eeg = EEG(edf_file)

# We extract the TimeSeries object corresponding to C3-A2
signal = get_channel(eeg, &quot;C3-A2&quot;) 

# Detect the NREM periods with default parameters.
nrems = nrem(staging)

# Split the C3 signal into 30-second windows (not-overlapping).
epochs = segment(signal, signal.fs * 30)

# PSD function to be used within each window in the spectrograms
psd = x -&gt; PSD(x, signal.fs, signal.fs * 5)

mean_delta_powers = []
for nrem_period in nrems
    # Extract the portion of the signal corresponding to this NREM period
    # This is a vector of vectors [vector_1, ..., vector_k], with the ith 
    # vector being the ith epoch in this NREM period.
    nrem_epochs = epochs[nrem_period]

    # Compute spectrogram with each window being an epoch of this nrem period.
    spec = Spectrogram(nrem_epochs, nrem_signal.fs*30, psd)

    # Compute mean power in delta band (0.5 to 3.9 Hz) from the spectrogram.
    δ = mean_band_power(spec, 0.5, 3.9)
    # Store the result in the mean_delta_powers list.
    push!(mean_delta_powers, δ)
end

# Now the ith element in `mean_delta_powers` is the mean delta power 
# of the ith NREM period.</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Sunday 23 February 2025 20:02">Sunday 23 February 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
