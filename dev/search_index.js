var documenterSearchIndex = {"docs":
[{"location":"#EEGToolkit.jl","page":"Home","title":"EEGToolkit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Computational EEG analysis with emphasis in sleep neuroscience.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Developed at the Laboratory for the Study of Sleep Slow-wave activity","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Gods of the earth and sea\nSought thro' Nature to find this Tree,\nBut their search was all in vain:\nThere grows one in the Human Brain.— William Blake","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package has three aims in mind: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simplicity\nTransparency\nEfficiency","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simplicity means that a scientist with little programming background should be able to use it. Transparency means that any methodology implemented by the package should be transparent enough so as to be reported in a scientific paper.  Efficiency means that large EEGs (e.g. sleep EEGs) should be processed and analyzed in minutes or less.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Transparency affects primarily spectral analysis (PSA). Most packages (e.g. the gsignal package in R) do not report how power spectrum analysis is done. Proprietary software is even less clear. This, combined with the fact that PSA is not standardized and may be computed in several many ways, makes it very difficult to compare and rest results. ","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Loading and processing EEG data\nEEG visualization\nSleep stage handling \nNREM Period detection\nPower spectral analysis\nSpindle detection algorithms","category":"page"},{"location":"#EEG","page":"Home","title":"EEG","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EEG\nepoch\nget_stage_indexes \nplot_eeg_overlay \ngen_time_domain\nget_stage \noverlaps \nplot_spectrogram\nfreq_band \nplot_eeg \nartifact_reject","category":"page"},{"location":"#EEGToolkit.EEG","page":"Home","title":"EEGToolkit.EEG","text":"A mutable struct representing EEG data with associated metadata.\n\nFields\n\nsignals::Dict{String, Vector{<:AbstractFloat}}: A dictionary mapping signal labels (strings) to arrays of floating-point values.\nsampling_rates::Dict{String, Integer}: A dictionary mapping signals (strings) to the integer sampling rates.\nfs::Integer: A default sampling rate that will be used for calculations. Defaults to the maximum sampling rate among all signals.\nepoch_length::Integer: Length of each epoch (in seconds).\nstaging::Vector{String}: A vector of stage labels corresponding to each epoch.\nid::String: An identifier for the EEG.\n\nConstructors\n\nEEG(file::String, epoch_length::Integer=30, staging::Vector{String}=[\"\"], id::String=\"\"): Constructs an EEG object from an EDF file (file) containing EEG data. The function reads the signals, computes the necessary metadata (fs, N, epoch_count), and initializes the EEG struct with the provided staging vector.\n\nExample\n\nstaging_vector = CSV.read(\"path/to/stage_data/eeg_staging.csv\") # A vector with a stage per each epoch in the EEG\neeg_data = EEG(\"path/to/edf_data/data.edf\", 30, staging_vector)\n\n# Alternatively, if no stage data exists, it is safe to do \neeg_data = EEG(\"path/to/edf_data/data.edf\", 30, [])\n\n# or simply \neeg_data = EEG(\"path/to/edf_data/data.edf\", 30) # Staging vector defaults to [] if not provided\n\n# or simply\neeg_data = EEG(\"path/to/edf_data/data.edf\") # Epoch length defaults to 30 if not provided.\n\n\n\n\n\n","category":"type"},{"location":"#EEGToolkit.epoch","page":"Home","title":"EEGToolkit.epoch","text":"epoch(eeg::EEG, n::Integer, fs::Integer=-1)\n\nReturns a vector [i₁, …, iₖ] with all indexes corresponding to the nth epoch of the EEG. The default sampling rate is used to compute the indexes.\n\n\n\n\n\nepoch(eeg::EEG, n::Integer, m::Integer, fs::Integer=-1)\n\nReturns a vector [i₁, …, iₖ] with all indexes corresponding to epochs n, n+1, …, m of the EEG. The default sampling rate is used to compute the indexes.\n\n\n\n\n\nepoch(eeg::EEG, n::Integer, channel::String)\n\nReturns a vector [x₁, …, xₖ] with all values of the signal channel in the nth epoch.\n\n\n\n\n\nepoch(eeg::EEG, n::Integer, m::Integer, channel::String)\n\nReturns a vector [x₁, …, xₖ] with all values of the signal channel in the epochs n, n+1, …, m.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.get_stage_indexes","page":"Home","title":"EEGToolkit.get_stage_indexes","text":"get_stage_indexes(eeg::EEG, stages::Vector)\n\nThis function maps an EEG and astages vector to the array of all indexes whose values in an EEG  signal pertain to a stage in stages.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.plot_eeg_overlay","page":"Home","title":"EEGToolkit.plot_eeg_overlay","text":"plot_eeg_overlay(eeg::EEG, channels::Vector{String}, n::Integer, m::Integer)\n\nPlots with the active backend all EEG channels in channels in the  range from the nth to the mth epoch.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.gen_time_domain","page":"Home","title":"EEGToolkit.gen_time_domain","text":"gen_time_domain(eeg::EEG, s::Union{AbstractFloat,Integer}, e::Union{AbstractFloat,Integer}, fs::Integer=-1)\n\nGiven an EEG, generates the time vector t₁, …, tₙ corresponding to  EEG signals from time s to e.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.get_stage","page":"Home","title":"EEGToolkit.get_stage","text":"function get_stage(eeg::EEG, channel::String, stages::Vector)\n\nReturns all portions of an EEG channel in a given stage of the staging vector.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.overlaps","page":"Home","title":"EEGToolkit.overlaps","text":"overlaps(v::Vector{T}, L::Int, overlap_frac::Union{Float64,Int}) where {T}\n\nSplits a vector v into segments of length L with an overlap overlap_frac expressed as a fraction of L. \n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.plot_spectrogram","page":"Home","title":"EEGToolkit.plot_spectrogram","text":"plot_spectrogram(spec::Spectrogram, freq_lim::AbstractFloat=30.0, type::Int=1, color=:nipy_spectral)\n\nPlots a spectogram spec either in 2d (type = 1) or 3d (type = 2). An optional  frequency limit (freq_lim) may be set (defaults to 30Hz). The color palette  color may be set; defaults to nipy_spectral.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.freq_band","page":"Home","title":"EEGToolkit.freq_band","text":"freq_band(spec::Union{PSD,AmplitudeSpectrum}, lower::AbstractFloat, upper::AbstractFloat)\n\nGiven a PSD, returns a Vector{AbstractFloat} with the powers within the frequency band [lower, upper].\n\n\n\n\n\nfreq_band(spec::Spectrogram, lower::AbstractFloat, upper::AbstractFloat, window::Integer)\n\nGiven a spectrogram, returns a Vector{<:AbstractFloat} with the powers within a frequency band [lower, upper] of a specific window (row of the spectrogram).\n\n\n\n\n\nfreq_band(spec::Spectrogram, lower::AbstractFloat, upper::AbstractFloat)\n\nGiven a spectrogram, returns a Matrix{<:AbstractFloat} with the powers within a frequency band [lower, upper] across all windows.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.plot_eeg","page":"Home","title":"EEGToolkit.plot_eeg","text":"Plots with the active backend all EEG channels in channels in the  range from the nth to the mth epoch.\n\n\n\n\n\nplot_eeg(eeg::EEG, channels::Vector{String}, n::Integer, m::Integer)\n\nPlots with the active backend all EEG channels in channels in the  range from the nth to the mth epoch.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.artifact_reject","page":"Home","title":"EEGToolkit.artifact_reject","text":"artifact_reject(eeg::EEG, anom_matrix::Matrix, signal::String)\n\nGiven an EEG, a 2x2 matrix associating epoch-subepoch pairs with artifacts, and a signal, returns a subset of the signal with all sub-epochs containing artifacts removed.\n\nThe signal is split in epoch-length windows and each window is split in subepoch-length  windows; the matrix gives the epoch and subepoch indexes to be removed. \n\n\n\n\n\n","category":"function"},{"location":"#NREM-Period-detection","page":"Home","title":"NREM Period detection","text":"","category":"section"},{"location":"#NREM-period-definition","page":"Home","title":"NREM period definition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Following Feinberg & Floyed and Dijk, a NREM period is a sequence of epochs satisfying the following conditions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"It starts with stages 2, 3 or 4. \nIt contains at least 15 minutes of stages 2, 3 or 4 exist in total.\nIt ends with either a at least 5 minutes of REM or b at least 5 minutes of wakefulness. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The sequence is allowed to contain ocurrences of REM sleep or wakefulness  in between, but the epochs corresponding to these occurrences will not be signaled as NREM. For example, in a stage sequence of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"... - 10 minutes of 2 - A minute of REM - 5 minutes of 3 - 5 minutes of REM - ...","category":"page"},{"location":"","page":"Home","title":"Home","text":"the NREM period consists of the first 10 minutes of stage 2 and the 5 minutes of stage 3, ignoring the 1 minute of REM in-between them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Importantly, the restriction that ending REM periods must last at least 5 minutes is not imposed when detecting the first and the last NREM period in a night of sleep.","category":"page"},{"location":"#NREM-detection-algorithm","page":"Home","title":"NREM detection algorithm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let n be the number of epochs corresponding to 15 minutes and m the number of epochs corresponding to 5 minutes. (In 30 second epohcs, n = 30 m = 10). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"For this algorithm to work, the staging field of an EEG object must have been set to a stage vector vecs, and this vector must contain only the strings 1 ldots 6  (with 5 marking REM, 6 wakefulness,  unknown/unstaged).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The algorithm works by mapping vecs to alpha = s_1 ldots s_q a word over the language generated by Sigma = 1 ldots 6.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Observe that the language (5+6)^*(2+3+4)^*^* is partitioned into U and U, where U is the set of words containing at least n symbols 2 3 4 where neither 5 nor 6 occur consecutively m = 10 times. Then alpha can be decomposed into ","category":"page"},{"location":"","page":"Home","title":"Home","text":"alpha = psi_1 phi_1 psi_2 phi_2 ldots psi_k phi_k psi_k+1","category":"page"},{"location":"","page":"Home","title":"Home","text":"where phi_i = varphi_i (5^m5^* + 6^m6^*) and varphi_i in U. Such a decomposition readily provides the number of NREM periods in the EEG (i.e. k). Furthermore, the epochs which comprise these periods are easily inferable from the decomposition.","category":"page"},{"location":"","page":"Home","title":"Home","text":"nrem","category":"page"},{"location":"#EEGToolkit.nrem","page":"Home","title":"EEGToolkit.nrem","text":"nrem(staging::Vector, n::Integer=30, m::Integer=10)\n\nFinds the k underlying NREM periods in a staging vector. Returns a vector of vectors V s.t. the ith vector in V  contains the epochs which comprise the ith NREM period. Thus, the length of V is k the number of NREM periods.\n\nThe staging field of the EEG must have been set to a vector  containing only the symbols 1, …, 6, ? where 5 denotes  REM, 6 denotes wakefulness, and ? denotes unscored/unstaged.\n\n\n\n\n\nnrem(eeg::EEG, n::Integer=30, m::Integer=10)\n\nFinds the k underlying NREM periods in the staging vector  of an EEG.\n\n\n\n\n\n","category":"function"},{"location":"#Spindle-detection","page":"Home","title":"Spindle detection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements two spindle detection algorithms discussed in O'Reilly and Nielsen (2015). We give a brief overview of them here but refer to their original publications for further detail.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sigma_index\nrelative_spindle_power","category":"page"},{"location":"#EEGToolkit.sigma_index","page":"Home","title":"EEGToolkit.sigma_index","text":"function sigma_index(x::Vector{<:AbstractFloat}, fs::Integer)\n\nThe Sigma-index algorithm (Huupponen et al., 2007) find spindles by detecting abnormally high amplitudes values among the spindle frequency band. Per each 1 second window of the EEG,\n\nthe maximum amplitude in the spindle frequency, which we call S_max\nthe average amplitude in the low alpha and theta frequencies, which we call\n\nalpha_mean theta_mean\n\nthe maximum alpha amplitude alpha_max\n\nare all computed. The Sigma-index is defined to be zero if alpha_max  S_max, and otherwise\n\nf(S_max alpha_mean phi_mean) = frac2S_max alpha_mean + phi_mean  \n\nHigher values are indicative of a higher spindle probability. The rejection threshold recommended in the original paper is lambda = 45.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.relative_spindle_power","page":"Home","title":"EEGToolkit.relative_spindle_power","text":"relative_spindle_power(x::Vector{<:AbstractFloat}, fs::Integer)\n\nThe Relative Spindle Power (RSP) algorithm (Devuyst et al., 2011) also detects abnormal values along the spindle frequency band. For every 1 second window, the amplitude spectrum S(t) is computed, and the RSP is defined as\n\nRSP(t) = fracint_11^16 S(t f) dfint_05^40 S(t f) df\n\nThis definition is more intelligible than the that of the sigma index, insofar as it represents the ratio of the total power in the spindle band with respect to the total power in the delta to phi frequency range. It is evident by definition that 0 leq RSP leq 1. Higher values are indicative of a higher spindle probability (it should be clear that RSP is not a probability itself). The rejection threshold recommended in the original paper is lambda = 022.\n\n\n\n\n\n","category":"function"},{"location":"#Power-spectral-analysis","page":"Home","title":"Power spectral analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AmplitudeSpectrum\nPSD\nSpectrogram","category":"page"},{"location":"#EEGToolkit.AmplitudeSpectrum","page":"Home","title":"EEGToolkit.AmplitudeSpectrum","text":"Structure for amplitude spectrum estimations. Estimations are by default  one sided, with frequencies ranging from [0, fₛ/2].\n\nThe formula used is \n\nfrac2H(f)sum_i w_i\n\nwith w_i a Hanning window.\n\nFields\n\nfreq::Vector{<:AbstractFloat}: Frequency range of the spectrum\nspectrum::Vector{<:AbstractFloat}: Estimated spectral amplitude\nformula::String: A string representation of the formula used for the estimation.\n\nConstructors\n\nAmplitudeSpectrum(x::Vector{<:AbstractFloat}, sampling_rate::Integer, pad::Integer) : Computes a direct PSD over a signal x with a given sampling_rate.\n\n\n\n\n\n","category":"type"},{"location":"#EEGToolkit.PSD","page":"Home","title":"EEGToolkit.PSD","text":"Structure for PSD estimations. Estimations are by default  one sided, with frequencies ranging from [0, fₛ/2].\n\nThe default formula is \n\nfrac2H(f)^2f_s sum_i w_i^2\n\nwith w_i a Hanning window. This means the estimation is normalized by  the sampling rate by default. This can be changed by setting the normalization  parameter equal to frac1f_s, canceling out the factor in the denominator. \n\nIf Barlett or Welch's mehtod is used (i.e. if the second constructor is used), the formula  becomes \n\nfrac1M varphi sum_i^M left frac2H_i(f)^2f_s sum_i w_i^2 right\n\nwhere w_1 ldots w_n a Hanning window, M the number of segments, H_i(f) the FFT of the ith segment of the signal, and varphi an optional normalization factor defined by the normalization parameter (defaults to 1).\n\nFields\n\nfreq::Vector{<:AbstractFloat}: Frequency range of the spectrum\nspectrum::Vector{<:AbstractFloat} : Estimated spectral density in dB.\nmethod::String: Estimation method used \nformula::String : A string representation of the formula used for the estimation.\n\nConstructors\n\nPSD(x::Vector, sampling_rate::Integer, pad::Integer = 0): Computes a direct PSD over a signal x with a given sampling_rate.\nPSD(x::Vector, fs::Int, L::Int, overlap::Union{ <:AbstractFloat, Integer }, normalization::Union{ <:AbstractFloat, Integer } = 1): Splits the signal x into segments of length L with an overlap in [0, 1). The overlap is understood to be a fraction of the segment length. PSD is estimated within and averaged across all segments. If overlap is zero, this results in Barlett's method. If overlap is greater than zero, this results in Welch's method. If pad is zero no zero-padding is done. If pad is greater than zero, each segment is zero-padded to a  length of pad. \n\n\n\n\n\n","category":"type"},{"location":"#EEGToolkit.Spectrogram","page":"Home","title":"EEGToolkit.Spectrogram","text":"Structure for spectrogram estimation. Estimations are by default one-sided, with frequencies ranging from [0, fₛ/2]. The signal is split into possibly overlapping  windows of length L; within each window, Welch's method is used to compute the  PSD with overlapping windows. For Barlett's method, one can set the inner window  length and the overlap to zero.\n\nFields\n\ntime::Vector : Time domain (x)\nfreq::Vector{<:AbstractFloat}: Frequency domain (y)\nspectrums::Matrix{<:AbstractFloat}: Power spectrum (z). Rows are time and columns are frequency.\nsegment_length::Integer : Length of each segment in time.\n\nConstructors\n\nSpectrogram(signal::Vector{<:AbstractFloat}, fs::Integer, segment_length::Integer, overlap::AbstractFloat, inner_window_length::Integer, inner_overlap::AbstractFloat) : Computes the Spectrogram of a signal with sampling rate fs in windows of length segment_length (in number of samples) with a certain overlap ∈ [0, 1].\n\nWithin each window, the PSD constructor is used to compute either a Welch or  a Barlett method estimation, depending on the inner_window_length and  inner_overlap parameters. An optional normalization factor and a zero-padding  length can be included, as in the PSD constructor.\n\nSpectrogram(segs::Vector{Vector{<:AbstractFloat}}, fs::Integer, segment_length::Integer, overlap::AbstractFloat, normalization::Union{AbstractFloat,Integer}=1, pad::Integer=0): This constructor does not take a signal but a split or windowed signal. This is useful, for example, when the EEG is split into windows corresponding to a specific period (e.g. NREM epochs). In this case, each time-instance in the Spectrogram corresponds to one of the windows. Aside from this, there is no difference with the previous constructor.\n\n\n\n\n\n","category":"type"},{"location":"#Helpers","page":"Home","title":"Helpers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"next_power_of_two \nzero_pad ","category":"page"},{"location":"#EEGToolkit.next_power_of_two","page":"Home","title":"EEGToolkit.next_power_of_two","text":"next_power_of_two(n::Int)\n\nGiven an integer n, finds the least m = 2ᵏ s.t. m ≥ n.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.zero_pad","page":"Home","title":"EEGToolkit.zero_pad","text":"zero_pad(v::Vector{<:AbstractFloat}, desired_length::Integer) where {T}\n\nZero-pads a numeric vector v to a desired_length\n\n\n\n\n\n","category":"function"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is an example script for computing the mean delta (delta) power in each of the NREM periods of a sleep EEG. We will use the C3 channel.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# First, import the package\nusing EEGToolkit \n\n# Assuming we have the stage data in a .csv and we have some function \n# to read CSVs (e.g. from the CSV package)\nstaging = some_function_to_read_csv(\"my_staging_data.csv\")\n\n# We read an EEG that has channels C3-A2 and F3-A1. We assume the CSV had a \n# column called STAGES with the stages of each epoch.\neeg = EEG(edf_file, staging.STAGES)\n\n# Detect the NREM periods\nnrems = nrem(eeg)\n\n# Split the C3 signal into 30-second windows (not-overlapping).\nepochs = overlaps(eeg.signals[\"C3-A2\"], eeg.fs * 30 * 30, 0)\n\nmean_delta_powers = []\nfor nrem_period in nrems\n    # Extract the portion of the signal corresponding to this NREM period\n    nrem_epochs = epochs[nrem_period]\n\n    # Compute its spectrogram. (Observation: This is an example of when it's useful to be \n    # able to pass a vector argument to the Spectrogram constructor.)\n    # The spectrogram of each epoch is computed with 5-sec windows wth a 0.5 \n    # overlap.\n    spec = Spectrogram(nrem_epochs, eeg.fs, eeg.fs*5 - 1, 0.5)\n\n    # Extract delta band (0.5 to 3.9 Hz) from the spectrogram.\n    delta_band = freq_band(spec, 0.5, 3.9)\n\n    # Compute the mean power in this delta band\n    mean_delta_power = mean(delta_band, dims=2) \n\n    # Store the result in the mean_delta_powers list.\n    push!(mean_delta_powers, mean_delta_power)\nend\n\n# Now the ith element in `mean_delta_powers` is the mean delta power \n# of the ith NREM period.","category":"page"}]
}
