var documenterSearchIndex = {"docs":
[{"location":"#EEGToolkit.jl","page":"Home","title":"EEGToolkit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Computational EEG analysis with emphasis in sleep neuroscience.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Developed at the Laboratory for the Study of Sleep Slow-wave activity","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Gods of the earth and sea\nSought thro' Nature to find this Tree,\nBut their search was all in vain:\nThere grows one in the Human Brain.— William Blake","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package has three aims: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simplicity\nTransparency\nEfficiency","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simplicity means that a person with only basic programming skills should be able to use it. Transparency means that any methodology implemented by the package should be accessible enough so as to be reported in a scientific paper. Efficiency means that large EEGs (e.g. sleep EEGs) should be processed and analyzed in seconds.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is free software—free as in freedom. You are free to use the code as you wish and for any purpose. You are free to study the code and change it to make it do what you wish. You are free to redistribute copies of this package to help others. You are free to distribute copies of any modified version of this package. Proprietary software hinders the liberty of its users. In science, it obscures the scientific process, difficulting replication and collaboration. If you are a scientist, use free software whenever possible.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Loading and processing EEG data\nEEG visualization\nSleep stage handling \nNREM Period detection\nPower spectral analysis\nSpindle detection algorithms\nAutomated artifact detection\nResampling\nHypnograms","category":"page"},{"location":"#Time-series","page":"Home","title":"Time series","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TimeSeries\nsegment\nepoch\nplot_ts\nseconds_to_time","category":"page"},{"location":"#EEGToolkit.TimeSeries","page":"Home","title":"EEGToolkit.TimeSeries","text":"A struct representing time series data.\n\nFields\n\nx::Vector{<:AbstractFloat}: Time series data.\nfs::Integer: Sampling rate.\n\n\n\n\n\n","category":"type"},{"location":"#EEGToolkit.segment","page":"Home","title":"EEGToolkit.segment","text":"segment(v::Vector{T}, L::Int; overlap::Union{<:AbstractFloat,Integer}=0, symmetric=false) where {T}\n\nSplits a vector v into segments of length L with an overlap overlap expressed as a fraction of L. The overlap defaults to 0 (no overlap). Returns a vector v of vectors - i.e. Vector{Vector{T}} - with vecv_i the ith segment in the split.\n\nThe function always attempts to capture the whole vector, even if the final split is not of length L. For example, \n\n> x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n> segment(x, 5)\n2-element Vector{Vector{Int64}}:\n[1, 2, 3, 4, 5]\n[6, 7, 8, 9, 0]\n\n> segment(x, 7)\n2-element Vector{Vector{Int64}}:\n[1, 2, 3, 4, 5, 6, 7]\n[8, 9, 0]\n\nSet symmetric=true to ensure that, if this occurs, the last split is dropped.\n\n> segment(x, 3; symmetric=true)\n3-element Vector{Vector{Int64}}:\n[1, 2, 3]\n[4, 5, 6]\n[7, 8, 9]\n\nIf L is equal to the segment length, segment raises a warning and returns a vector with only the original vector: [v].  The return value ensures type-safety but the warning is raised because  splitting a vector over its length is potentially  a programming mistake.\n\n\n\n\n\nsegment(ts::TimeSeries, L::Int; kargs...)\n\nWrapper to segment the vector ts.x in the time  series ts.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.epoch","page":"Home","title":"EEGToolkit.epoch","text":"epoch(signal::TimeSeries, n::Integer; epoch_length::Integer=30)\n\nReturns a vector [x₁, …, xₖ] with all values xᵢ corresponding to the nth epoch in the signal.\n\n\n\n\n\nepoch(signal::TimeSeries, n::Integer, m::Integer)\n\nReturns a vector [x₁, …, xₖ] with all indexes corresponding to epochs n, n+1, …, m of the EEG. The default sampling rate is used to compute the indexes.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.plot_ts","page":"Home","title":"EEGToolkit.plot_ts","text":"plot_ts(ts::TimeSeries, s::Integer, e::Integer; norm=false, ylab=\"Amplitude (uV)\")\n\nPlots TimeSeries from epoch s to epoch e. The series many be normalized.\n\n\n\n\n\nplot_ts(ts::TimeSeries, s::Integer; kargs...)\n\nPlots TimeSeries at epoch s.\n\n\n\n\n\nplot_ts(ts::TimeSeries; norm=false, ylab=\"Amplitude (uV)\")\n\nPlots TimeSeries. The series may be normalized.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.seconds_to_time","page":"Home","title":"EEGToolkit.seconds_to_time","text":"seconds_to_time(seconds::Union{AbstractFloat, Integer})\n\nHelper function: maps a time in seconds to a Time object.\n\n\n\n\n\n","category":"function"},{"location":"#EEG","page":"Home","title":"EEG","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EEG\nremove_channel!\nplot_eeg\nartifact_reject","category":"page"},{"location":"#EEGToolkit.EEG","page":"Home","title":"EEGToolkit.EEG","text":"A struct for the EEG data type. An EEG is simply conceived as a collection of labeled time series.\n\nFields\n\nsignals::Dict{String, TimeSeries}: A dictionary mapping signal labels (strings) to arrays of floating-point values.\n\nConstructors\n\nEEG(file::String; id::String=\"\"): Instantiates an EEG from an EDF file (file).\n\nExample\n\neeg_data = EEG(\"path/to/edf_data/data.edf\")\n\n\n\n\n\n","category":"type"},{"location":"#EEGToolkit.remove_channel!","page":"Home","title":"EEGToolkit.remove_channel!","text":"remove_channel!(eeg::EEG, channel::String)\n\nRemoves a channel from the EEG.\n\n\n\n\n\nremove_channel!(eeg::EEG, channels::Vector{String})\n\nRemoves a list of channels from the EEG.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.plot_eeg","page":"Home","title":"EEGToolkit.plot_eeg","text":"plot_eeg(eeg::EEG, s::Integer, e::Integer; channels::Vector{String}=[\"\"], spacing::AbstractFloat=1.5)\n\nPlots EEG channels from epoch s to epoch e. Specific channels may be selected with the channels karg. The spacing argument is an added factor in the normalization of the EEG signals - the vertical distance between each signal in the plot grows proportionally to spacing.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.artifact_reject","page":"Home","title":"EEGToolkit.artifact_reject","text":"function artifactreject(signal::TimeSeries, anomdict::Dict{Int, Vector{Int}}; epochlength::Integer=30, subepochlength::Integer=5)::Vector{Vector{<:AbstractFloat}};\n\nThis function removes from a signal the sub-epochs which contain artifacts.  It requires a TimeSeries and a Dict{Int, Vector{Int}}, hereby termed  anom_dict (for anomaly dictionary). \n\nanom_dict is understood to be such that anom_dict[i] = [n₁, …, nₖ] means the ith epoch has artifacts at sub-epochs n₁, ..., nₖ.\n\nThe return value is a segmented signal (Vector{Vector<:AbstractFloat}}), each  of whose segments corresponds to an epoch with its artifcat-contaminated  sub-epochs removed. In other words, if the result   holds   the   return    value   of    this    function,    result[i] contains   what   is   left   from    the    ith    epoch    after    removing its   contaminated   sub-epochs.   It   is   possible   that   result[i]    is empty, if all sub-epochs of epoch i contained artifacts.\n\n\n\n\n\nartifact_reject(signal::TimeSeries, anoms::Vector{Integer}; epoch_length::Integer=30)\n\nAn anomaly vector vecx in mathbbN^n is a sorted vector whose values are those epochs in an TimeSeries that contain  anomalies or artifacts. This function segments the TimeSeries and filters out all  epochs containing artifacts.\n\n\n\n\n\n","category":"function"},{"location":"#NREM-Period-detection","page":"Home","title":"NREM Period detection","text":"","category":"section"},{"location":"#NREM-period-definition","page":"Home","title":"NREM period definition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Following Feinberg & Floyed and Dijk, a NREM period is a sequence of epochs satisfying the following conditions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"It starts with stages 2, 3 or 4. \nIt contains at least 15 minutes of stages 2, 3 or 4 in total.\nIt ends with 5 or more minutes of REM, or with 5 or more minutes of wakefulness. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Epochs in the sequence are allowed to contain occurrences of REM sleep or wakefulness  in between, as long as the duration of this occurrences is less than 5 minutes. But the epochs corresponding to these occurrences will not be part of the NREM period. For example, in a stage sequence of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"... - 10m of stage two - 1m of REM - 5m of stage three - 5m of REM - ...","category":"page"},{"location":"","page":"Home","title":"Home","text":"the NREM period consists of the first 10 minutes of stage 2 and the 5 minutes of stage 3, ignoring the 1 minute of REM in-between them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Importantly, the restriction that ending REM periods must last at least 5 minutes is not imposed when detecting the first and the last NREM period in a night of sleep.","category":"page"},{"location":"#NREM-detection-algorithm","page":"Home","title":"NREM detection algorithm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let n be the number of epochs corresponding to 15 minutes and m the number of epochs corresponding to 5 minutes. (In 30 second epochs, n = 30 m = 10). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The algorithm assumes that the  staging field of an EEG has been set to a vector vecs that contains only the strings 1 ldots 6  (with 5 marking REM, 6 wakefulness,  unknown/unstaged).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The algorithm works by mapping vecs to alpha = s_1 ldots s_q a word over the language generated by Sigma = 1 ldots 6 .","category":"page"},{"location":"","page":"Home","title":"Home","text":"Observe that the language (5+6)^*(2+3+4)^*^* is partitioned into U and U, where U is the set of words containing at least n symbols 2 3 4 where neither 5 nor 6 occur consecutively m times. Then alpha can be decomposed into ","category":"page"},{"location":"","page":"Home","title":"Home","text":"alpha = psi_1 phi_1 psi_2 phi_2 ldots psi_k phi_k psi_k+1","category":"page"},{"location":"","page":"Home","title":"Home","text":"where phi_i = varphi_i (5^m5^* + 6^m6^*) and varphi_i in U. Such a decomposition readily provides the number of NREM periods in the EEG (i.e. k). Furthermore, the epochs which comprise these periods are easily inferable from the decomposition.","category":"page"},{"location":"","page":"Home","title":"Home","text":"nrem","category":"page"},{"location":"#EEGToolkit.nrem","page":"Home","title":"EEGToolkit.nrem","text":"function nrem(staging::Staging, n::Integer=30, m::Integer=10)\n\nFinds the k underlying NREM periods in a staging vector. Returns a vector of vectors V s.t. the ith vector in V  contains the epochs which comprise the ith NREM period. Thus, the length of V is k the number of NREM periods.\n\nThe n parameter is the number of (not necessarily consecutive)  epochs which comprise a NREM period. The m parameter is the  number of REM or wakefulness epochs required to mark the end  of a NREM period (if n NREM epochs were parsed before) or to  disregard the current sequence and begin parsing from the next  NREM epoch.\n\nThe staging parameter is a vector containing only the  symbols 1, …, 6, ? where 5 denotes REM, 6 denotes  wakefulness, and ? denotes unscored/unstaged.\n\n\n\n\n\n","category":"function"},{"location":"#Spindle-detection","page":"Home","title":"Spindle detection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements two spindle detection algorithms discussed in O'Reilly and Nielsen (2015). We give a brief overview of them here but refer to their original publications for further detail.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sigma_index\nrelative_spindle_power","category":"page"},{"location":"#EEGToolkit.sigma_index","page":"Home","title":"EEGToolkit.sigma_index","text":"sigma_index(x::Vector{<:AbstractFloat}, fs::Integer)\n\nThe sigma-index algorithm (Huupponen et al., 2007) find abnormally high amplitude values in the spindle frequency band. Per each 1 second window of the EEG, it computes\n\nthe maximum amplitude in the spindle frequency band, which we call S_max\nthe average amplitude in the low alpha and theta frequencies, which we call\n\nalpha_mean theta_mean\n\nthe maximum alpha amplitude alpha_max\n\nThe sigma-index of each window is defined to be zero if alpha_max  S_max, and otherwise\n\nf(S_max alpha_mean phi_mean) = frac2S_max alpha_mean + theta_mean  \n\nHigher values are indicative of a higher spindle probability. The rejection threshold recommended in the original paper is lambda = 45.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.relative_spindle_power","page":"Home","title":"EEGToolkit.relative_spindle_power","text":"relative_spindle_power(x::Vector{<:AbstractFloat}, fs::Integer)\n\nThe Relative Spindle Power (RSP) algorithm (Devuyst et al., 2011)  also detects abnormal values along the spindle frequency band.  For every 1 second window, the amplitude spectrum S(t) is computed,  and the RSP is defined as\n\nRSP(t) = fracint_11^16 S(t f) dfint_05^40 S(t f) df\n\nThis definition is more intelligible than the that of the sigma-index, insofar as it represents the ratio of the total power in the spindle band with respect to the total power in the 05 40 frequency range. It is evident by definition that 0 leq RSP leq 1. Higher values are indicative of a higher spindle probability (it should be clear that RSP is not a probability itself). The rejection threshold recommended in the original paper is lambda = 022.\n\n\n\n\n\n","category":"function"},{"location":"#Power-spectral-analysis","page":"Home","title":"Power spectral analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AmplitudeSpectrum\nPSD\nplot_psd\nSpectrogram\nplot_spectrogram\nfreq_band \nmean_band_power\ntotal_band_power\nanalyze_eeg","category":"page"},{"location":"#EEGToolkit.AmplitudeSpectrum","page":"Home","title":"EEGToolkit.AmplitudeSpectrum","text":"Structure for amplitude spectrum estimations. Estimations are by default  one sided, with frequencies ranging from [0, fₛ/2]. The formula used is \n\nfrac2H(f)sum_i w_i\n\nwith w_i a Hanning window.\n\nFields\n\nfreq::Vector{<:AbstractFloat}: Frequency range of the spectrum\nspectrum::Vector{<:AbstractFloat}: Estimated spectral amplitude\n\nConstructors\n\nAmplitudeSpectrum(x::Vector{<:AbstractFloat}, sampling_rate::Integer, pad::Integer) : Computes a direct PSD over a signal x with a given sampling_rate.\n\n\n\n\n\n","category":"type"},{"location":"#EEGToolkit.PSD","page":"Home","title":"EEGToolkit.PSD","text":"Structure for PSD estimations. Estimations are by default  one sided, with frequencies ranging from [0, fₛ/2].\n\nThe default formula is \n\nfrac2H(f)^2zeta sum_i w_i^2\n\nwith w_1 ldots w_n a Hanning window and zeta a normalization factor which defaults  to 1.  \n\nBarlett or Welch's mehtod can be used, where the formula  becomes \n\nfrac1M K varphi sum_i^M left frac2H_i(f)^2 sum_i w_i^2 right\n\nwhere w_1 ldots w_n a Hanning window, M the number of segments, K the number of samples per segment, H_i(f) the FFT of the ith segment of the signal, and varphi a normalization factor defaulting to 1.\n\nFields\n\nfreq::Vector{<:AbstractFloat}: Frequency range of the spectrum\nspectrum::Vector{<:AbstractFloat} : Estimated spectral density in dB.\n\nConstructors\n\nPSD(x::Vector{<:AbstractFloat}, fs::Integer; window_function::Function = hanning, pad::Integer=0, normalization::Real=1): Computes PSD estimation of a signal x with sampling rate fs. A window_function is applied to the signal, defaulting to a Hanning window. The signal may be padded to an optional length pad (defaults to zero, i.e. no padding). A Real normalization is added to the denominator, which defaults to 1.\nPSD(segs::Vector{Vector{T}}, fs::Integer; window_function=hanning, normalization::Real=1) where {T<:AbstractFloat}: Computes the average spectrum of the segment vectors segs. The estimation is normalized with a normalization that defaults to 1. The window_function is applied to all segments prior to their PSD estimation.\n\nPSD(x::Vector{<:AbstractFloat}, fs::Integer, seg_length::Integer; overlap::Union{<:AbstractFloat,Integer} = 0.5, window_function::Function=hanning, normalization::Real=1): Segments the signal x into segments of length seg_length, with an overlap of overlap which defaults to 0.5 (half the segment length). After signal segmentation, the average spectrum of the resulting segments is returned. A window_function is applied to all segments prior to their PSD estimation, defaulting to a Hanning window. The final estimation is normalized with a normalization factor that defaults to 1.\n\nPSD(ts::TimeSeries; kargs...) : Wrapper to apply the first or second constructor to a TimeSeries signal.\nPSD(ts::TimeSeries, seg_length::Integer; kargs...): Wrapper to apply the third constructor to a TimeSeries signal.\nPSD(freq::Vector{<:AbstractFloat},  spectrum::Vector{<:AbstractFloat}): Direct constructor.\n\n\n\n\n\n","category":"type"},{"location":"#EEGToolkit.plot_psd","page":"Home","title":"EEGToolkit.plot_psd","text":"plot_psd(psd::PSD; freq_lim=30.0)\n\nPlot a PSD with x-axis being frequency and y-axis being estimated power spectrum.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.Spectrogram","page":"Home","title":"EEGToolkit.Spectrogram","text":"A spectrogram is a matrix S^M times F where M is the number of windows in  the windowing of a signal and F is the length of the spectrum vector in any given window (i.e. the frequency resolution).  It is useful to observe spectral changes in time or to compute the  spectrum of time-regions of interest (e.g. only NREM periods in a sleep EEG).  The information available in direct PSD can be inferred from the spectrogram with ease.\n\nFor instance, let f_1 f_2 ldots f_k be a strictly increasing sequence of frequencies. Assume these frequencies correspond to the column indexes c_1 c_2 ldots c_k of S. Then the mean power in the frequency range  f_1 f_k is\n\nfrac1M sum_i=1^Mleftfrac1c_k - c_1sum_j=c_1^c_k S_ijright = frac1Mbig(c_k - c_1big)sum_i=1^Msum_j=c_1^c_k S_ij\n\nIn this package, mean power in a frequency range is computed with the mean_band_power function.\n\nFields\n\ntime::Vector : Time domain \nfreq::Vector{<:AbstractFloat}: Frequency domain \nspectrums::Matrix{<:AbstractFloat}: Power spectrum. Rows are time and columns are frequency; the value in spectrums[row, freq] is the power at time window row for frequency freq.\nsegment_length::Integer : Length of each segment in time.\naggregated_spectra::Vector{<:AbstractFloat} : Spectral average (mean of rows)\n\nConstructors\n\nSpectrogram(segs::Vector{Vector{T}}, psd_function::Function; dB = false) where {T<:AbstractFloat}: Given a sequence of windows w_1 ldots w_k contained in the segs argument, computes the PSD within each window using a custom psd_function. \nSpectrogram(signal::Vector{<:AbstractFloat}, window_length::Integer, psd_function::Function; overlap::Union{AbstractFloat, Integer}=0, dB=false): Splits a signal into (potentially overlapping) segments of length window_length and computes the Spectrogram over this windowing using the first constructor. A custom psd_function is used within each window. Symmetry is enforced over the split signal, meaning that if the last segment is of length not equal to the rest, it is dropped. Thus, all windows are of equal length.\nfunction Spectrogram(ts::TimeSeries, window_length::Integer, psd_function::Function; kargs...): Wrapper constructor for a TimeSeries object.\n\n\n\n\n\n","category":"type"},{"location":"#EEGToolkit.plot_spectrogram","page":"Home","title":"EEGToolkit.plot_spectrogram","text":"plot_spectrogram(spec::Spectrogram; freq_lim::AbstractFloat=30.0, type::Int=1, color=:nipy_spectral)\n\nPlots a spectogram spec either in 2d (type = 1) or 3d (type = 2). An optional  frequency limit (freq_lim) may be set (defaults to 30Hz). The color palette  color may be set; defaults to nipy_spectral.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.freq_band","page":"Home","title":"EEGToolkit.freq_band","text":"freq_band(spec::Union{PSD}, lower::AbstractFloat, upper::AbstractFloat)\n\nGiven a PSD, returns a Vector{<:AbstractFloat} with the powers within the frequency band [lower, upper].\n\n\n\n\n\nfreq_band(spec::Spectrogram, lower::AbstractFloat, upper::AbstractFloat, window::Integer)\n\nGiven a Spectrogram, returns a Vector{<:AbstractFloat} with the powers within a frequency band [lower, upper] of a specific window (row of the spectrogram).\n\n\n\n\n\nfreq_band(spec::Spectrogram, lower::AbstractFloat, upper::AbstractFloat)\n\nGiven a Spectrogram, returns a Matrix{<:AbstractFloat} with the powers within a frequency band [lower, upper] across all time windows.\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.mean_band_power","page":"Home","title":"EEGToolkit.mean_band_power","text":"mean_band_power(spec::Spectrogram, lower::AbstractFloat, upper::AbstractFloat)\n\nGiven a Spectrogram, returns the mean power in a given frequency band [lower, upper]. This function  effectively computes \n\nfrac1Mbig(c_k - c_1big)sum_i=1^Msum_j=c_1^c_k S_ij\n\n\n\n\n\nmean_band_power(spec::PSD, lower::AbstractFloat, upper::AbstractFloat)\n\nGiven a PSD, returns the mean power in a given frequency band [lower, upper]. \n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.total_band_power","page":"Home","title":"EEGToolkit.total_band_power","text":"total_band_power(psd::PSD, lower::AbstractFloat, upper::AbstractFloat)\n\nGiven a PSD, computes the total power in the frequency band [lower, upper].\n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.analyze_eeg","page":"Home","title":"EEGToolkit.analyze_eeg","text":"analyze_eeg(signal::Vector{<:AbstractFloat}, fs::Integer)::Spectrogram\n\nPerform a standardized analysis of an EEG signal. This analysis procedure  succesfully replicated results from Washington State University in collaboration with the developer's laboratory at UPenn. \n\nThe standardized procedure is as follows: split the signal into 30-sec epochs, each of which is split into 5-sec sub-epochs. Each epoch's spectrum is the  aggregated spectra from its sub-epochs; the signal's spectrum is the aggregated  spectra from its epochs. Rectangular window is used. Overlap is set to zero. No normalization is performed.\n\n\n\n\n\nanalyze_eeg(signal::Vector{<:AbstractFloat}, fs::Integer, epoch_indexes::Vector{<:Integer})::Spectrogram\n\nPerform a standardized analysis of the specified epochs of an EEG signal.  This analysis procedure succesfully replicated results from Washington State  University in collaboration with the developer's laboratory at UPenn. \n\nThe standardized procedure is as follows: split the signal into 30-sec epochs, each of which is split into 5-sec sub-epochs. Each epoch's spectrum is the  aggregated spectra from its sub-epochs; the signal's spectrum is the aggregated  spectra from its epochs.\n\n\n\n\n\n","category":"function"},{"location":"#Artifact-detection","page":"Home","title":"Artifact detection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides an interface of the CAPA statistical method (Fisch, Eckley & Fearnhead, 2021) via the RCall package. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is not a requirement to have RCall installed to use other features of this package, but it is a requirement for artifact detection. Calling artifact detection functions without RCall installed will result in  an error and a prompt to install RCall.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CAPA is an automated anomaly detection algorithm which performs in linear time and is specifically designed for time series analysis. The adaptation provided in this package detects epidemic changes in the mean of each segment of the EEG, where the segment length is a parameter. The algorithm is relatively fast, considering the high complexity of EEG recordings.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For instance, on a 15.5 million samples EEG record with 8 channels (all artifact-detected), with a segment length of 30 * 5 seconds, the algorithm took ≈8.6 minutes on a computer with an I3 processor and 8GB of RAM. That's 8.6/8 = 1.075 minutes per channel, i.e. practically a minute per each 15.5 million-sized vector, on a mediocre computer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"detect_artifacts\nplot_artifacts_in_epochs","category":"page"},{"location":"#EEGToolkit.detect_artifacts","page":"Home","title":"EEGToolkit.detect_artifacts","text":"function detect_artifacts(eeg::EEG, channel_name::String, seg_length::Int)::Nothing\n\nPerforms artifact detection in the eeg channel named channel_name.  Stores resulting vector of Artifact objects in the _artifacts dictionary of the eeg with key channel_name. \n\nArtifact detection is performed on each segment of the signal segmented with seg_length. On each segment, the CAPA algorithm (Fisch et. al 2022) is used  to detect epidemic distributional changes in the mean value of the segment.  The penalty is an integer value β such that β ln(n) (with n the segment's length)  is the penalty used by the CAPA algorithm to penalize the introduction of artifacts. The β penalty defaults to 24, which is much higher than the value recommended  in Fisch et. al but matched human supervision on 78Hz sleep EEGs at the  developer's laboratory. \n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.plot_artifacts_in_epochs","page":"Home","title":"EEGToolkit.plot_artifacts_in_epochs","text":"function plot_artifacts_in_epochs(signal::TimeSeries, artifacts::ArtifactData,                                    from::Integer, to::Integer;                                    annotate::Bool=false)\n\nGiven a signal and a non-empty vector of artifacts, plots the signal and highlights the existing artifacts from epoch from to epoch to. If annotate is set to true, artifacts are annotated with their mean change and test statistic.\n\n\n\n\n\nfunction plotartifactsinepochs(eeg::EEG, channelname::String,\n\nGiven an eeg and an artifact-detected channel_name, plots the existing artifacts in the channel from epoch from to epoch to. If annotate is set to true, artifacts are annotated with their mean change and test statistic.\n\n\n\n\n\n","category":"function"},{"location":"#Resampling","page":"Home","title":"Resampling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"resample ","category":"page"},{"location":"#EEGToolkit.resample","page":"Home","title":"EEGToolkit.resample","text":"resample(signal::TimeSeries, new_fs::Float64)::TimeSeries\n\nResamples the input signal to the given new_fs, using rational factor  resampling (L/M). Returns a new TimeSeries with the resampled signal and  updated sampling rate.\n\n\n\n\n\n","category":"function"},{"location":"#Helpers","page":"Home","title":"Helpers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"next_power_of_two \nzero_pad ","category":"page"},{"location":"#EEGToolkit.next_power_of_two","page":"Home","title":"EEGToolkit.next_power_of_two","text":"Given an integer n, finds the least m = 2^k s.t. m geq n. \n\n\n\n\n\n","category":"function"},{"location":"#EEGToolkit.zero_pad","page":"Home","title":"EEGToolkit.zero_pad","text":"zero_pad(v::Vector{T}, desired_length::Integer) where {T<:AbstractFloat}\n\nZero-pads a numeric vector v to a desired_length\n\n\n\n\n\n","category":"function"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#Resampling-2","page":"Home","title":"Resampling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"file = \"myeeg.edf\" \neeg = EEG(file)\nsignal = get_channel(eeg, \"EEG6\")\nresampled = resample(signal, 10.0) # Resample signal to 10Hz.\np1 = plot_ts(signal, 30, 30) # Plot epoch 30\np2 = plot_ts(resampled, 30, 30) # Plot epoch 30\n\np = plot(p1, p2, layout=(2, 1), link=:x, legend=false)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Hypnogram","page":"Home","title":"Hypnogram","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"staging = CSV.read(\"staging.csv\", DataFrame) # Some staging data\nreplace!(staging, \"NS\" => \"?\", \"REM\" => \"5\", \"WK\" => \"6\", \"N1\" => \"1\", \"N2\" => \"2\", \"N3\" => \"3\", \"N4\" => \"4\") # Convert it to appropriate format (see Staging data type)\nstaging = Staging(staging) # Convert to Staging data type\np = plot_hypnogram(staging) # Plot","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Artifact-detection-2","page":"Home","title":"Artifact detection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Consider the REPL commands below, which read an EEG from an EDF file, perform artifact detection on each 5min segment of the EEG channel EEG6, and plots the artifacts from epochs 30 to 60 with annotations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> file = \"SWAIVF004.edf\" \n\"SWAIVF004.edf\"\njulia> eeg = EEG(file)\njulia> detect_artifacts(eeg, \"EEG6\", 60*5)  # epoch length = 5 minutes\njulia> get_artifacts(eeg) # Just to show what changes after running `detect artifacts`  on channel EEG6.\nDict{String, Union{Nothing, Vector{Artifact}}} with 11 entries:\n  \"Light\"    => nothing\n  \"Sound\"    => nothing\n  \"HR\"       => nothing\n  \"PAT\"      => nothing\n  \"Head Pos\" => nothing\n  \"EEG6\"     => Artifact[Artifact((1, 152), 33.1202, 5034.28, 1, 1), Artifact((173, 283), 9.70824, 1077.61, 1, 1), Artifact((23575, 23610), 32.582, 1172.95, 11, 1), Artifact((24197, …\n  \"EEG5\"     => nothing\n  ⋮          => ⋮\n\njulia> plot_artifacts_in_epochs(eeg, \"EEG6\", 30, 60; annotate=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Spectrogram","page":"Home","title":"Spectrogram","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"file = \"myeeg.edf\" \neeg = EEG(file)\nsignal = get_channel(eeg, \"EEG6\")\npsd = x -> PSD(x, signal.fs, signal.fs * 5)\nS = Spectrogram(signal, x -> custom_psd(x, signal.fs))\n\nplot_spectrogram(S; type::Int=2) # Type 2 for 3D plot.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#NREM-delta-power","page":"Home","title":"NREM delta power","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is an example script for computing the mean delta (delta) power in each of the NREM periods of a sleep EEG. We will use the C3 channel.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Assuming we have the stage data in a .csv \nstaging_df = CSV.read(\"my_staging_data.csv\", DataFrame)\n\n# Assuming the csv had a column named STAGES with the stage of each epoch.\nstaging = staging_df.STAGES\n\n# We read an EEG that has channels C3-A2 and F3-A1. We assume the CSV had a \n# column called STAGES with the stages of each epoch.\neeg = EEG(edf_file)\n\n# We extract the TimeSeries object corresponding to C3-A2\nsignal = get_channel(eeg, \"C3-A2\") \n\n# Detect the NREM periods with default parameters.\nnrems = nrem(staging)\n\n# Split the C3 signal into 30-second windows (not-overlapping).\nepochs = segment(signal, signal.fs * 30)\n\n# PSD function to be used within each window in the spectrograms\npsd = x -> PSD(x, signal.fs, signal.fs * 5)\n\n# Compute the spectrogram of the full signal\nS = Spectrogram(signal, x -> custom_psd(x, signal.fs))\n\n# Retrieve the indexes (rows) which correspond to delta power.\ndelta_band = findall(x -> x >= 0.3 && x <= 3.9, S.freq)\n\npowers = []\nfor nrem_period in nrems\n    # Extract the portion of the signal corresponding to this NREM period\n    # This is a vector of vectors [vector_1, ..., vector_k], with the ith \n    # vector being the ith epoch in this NREM period.\n    nrem_epochs = epochs[nrem_period]\n\n    # From the spectrogram, retrieve the epochs corresponding to this NREM\n    # period and rows corresponding to delta power.\n    sub_spectrogram = S.spectrums[period, delta_band]\n\n    # Compute the mean power within that NREM period. \n    power = mean( sum(sub_spectrogram, dims=2) )\n    # Compute spectrogram with each window being an epoch of this nrem period.\n    spec = Spectrogram(nrem_epochs, .fs*30, psd)\n    # Add the computed mean delta power to the powers vector.\n    push!(powers, power)\nend\n\n# Now the ith element in `powers` is the mean delta power # of the ith NREM\nperiod.","category":"page"}]
}
